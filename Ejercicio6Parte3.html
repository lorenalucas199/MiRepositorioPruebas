<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Teorema de Euclides - Catetos</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/algebrite/1.5.0/algebrite.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; }
    canvas { border: 1px solid #ccc; background: #fff; display: block; margin: 20px auto; }
    #info {
      max-width: 600px;
      margin: 0 auto;
      background: #f0f0f0;
      padding: 10px;
      border-radius: 10px;
    }
  </style>
</head>
<body>

<canvas id="canvas" width="600" height="400"></canvas>
<div id="info"></div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const info = document.getElementById("info");

  let A = { x: 100, y: 300 }; // ángulo recto
  let B = { x: 500, y: 300 };
  let C = { x: 100, y: 100 };

  let dragging = null;

  function dist(p1, p2) {
    return Math.hypot(p1.x - p2.x, p1.y - p2.y);
  }

  function projectionPoint(A, B, P) {
    const ABx = B.x - A.x;
    const ABy = B.y - A.y;
    const t = ((P.x - A.x) * ABx + (P.y - A.y) * ABy) / (ABx * ABx + ABy * ABy);
    return {
      x: A.x + t * ABx,
      y: A.y + t * ABy
    };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Triángulo
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.lineTo(C.x, C.y);
    ctx.closePath();
    ctx.fillStyle = "#ddd";
    ctx.fill();
    ctx.strokeStyle = "#000";
    ctx.stroke();

    // Altura desde C a hipotenusa AB
    const H = projectionPoint(A, B, C);
    ctx.beginPath();
    ctx.moveTo(C.x, C.y);
    ctx.lineTo(H.x, H.y);
    ctx.strokeStyle = "red";
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Proyecciones
    const D = projectionPoint(A, B, C); // pie de la altura
    const m = dist(A, D); // proyección de cateto b
    const n = dist(B, D); // proyección de cateto a
    const c = dist(A, B);
    const a = dist(C, B); // cateto a
    const b = dist(C, A); // cateto b

    const a2 = a * a;
    const b2 = b * b;
    const cm = c * m;
    const cn = c * n;

    const simb1 = Algebrite.run(`simplify(${a2} - (${c} * ${n}))`);
    const simb2 = Algebrite.run(`simplify(${b2} - (${c} * ${m}))`);

    // Puntos
    [A, B, C, D].forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "#333";
      ctx.fill();
    });

    ctx.fillText("A", A.x - 15, A.y + 5);
    ctx.fillText("B", B.x + 5, B.y + 5);
    ctx.fillText("C", C.x - 10, C.y - 10);
    ctx.fillText("D", D.x + 5, D.y - 5);

    info.innerHTML = `
      <strong>Teorema de Euclides para los catetos:</strong><br>
      Cateto a = ${a.toFixed(2)} → a² = ${a2.toFixed(2)}<br>
      Proyección n = ${n.toFixed(2)} → c · n = ${cn.toFixed(2)}<br>
      <strong>Verificación:</strong> a² ${Math.abs(a2 - cn) < 0.1 ? "≈" : "≠"} c · n → ${simb1}<br><br>

      Cateto b = ${b.toFixed(2)} → b² = ${b2.toFixed(2)}<br>
      Proyección m = ${m.toFixed(2)} → c · m = ${cm.toFixed(2)}<br>
      <strong>Verificación:</strong> b² ${Math.abs(b2 - cm) < 0.1 ? "≈" : "≠"} c · m → ${simb2}
    `;
  }

  function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
  }

  canvas.addEventListener("mousedown", e => {
    const pos = getMousePos(e);
    if (dist(pos, C) < 10) dragging = "C";
  });

  canvas.addEventListener("mousemove", e => {
    if (dragging === "C") {
      C = getMousePos(e);
      draw();
    }
  });

  canvas.addEventListener("mouseup", () => dragging = null);
  canvas.addEventListener("mouseleave", () => dragging = null);

  draw();
</script>

</body>
</html>
